<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebRTC + SSE Test</title>

  <style>
    body {
      font-family: monospace;
      background: #f9f9f9;
    }
    button {
      margin-right: 8px;
    }
    #log {
      white-space: pre-wrap;
      border: 1px solid #ccc;
      padding: 8px;
      height: 600px;
      overflow-y: auto;
      background: #fff;
    }
  </style>
</head>
<body>

<h2>Transport Test</h2>

<button id="startRtc">Start WebRTC</button>
<button id="startSse">Start SSE</button>

<br><br>

<input id="msg" placeholder="Type message…" />
<button id="send" disabled>Send (RTC only)</button>

<pre id="log"></pre>

<!-- MessagePack -->
<script src="https://cdn.jsdelivr.net/npm/@msgpack/msgpack/dist/msgpack.min.js"></script>

<script>
(() => {
  let rtcChannel = null;
  let sse = null;
  let msgCount = 0;

  const ENDPOINT = "http://192.168.1.106:54124";

  const log = m => {
    const el = document.getElementById("log");
    el.textContent += m + "\n";
    el.scrollTop = el.scrollHeight;
  };

  // =======================================================
  // WebRTC
  // =======================================================
  document.getElementById("startRtc").onclick = async () => {
    log("Starting WebRTC…");

    const pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    // Dummy channel to avoid trickle ICE
    pc.createDataChannel("dummy");

    pc.ondatachannel = e => {
      rtcChannel = e.channel;

      rtcChannel.onopen = () => {
        log("WebRTC DataChannel open");
        document.getElementById("send").disabled = false;
      };

      rtcChannel.onmessage = e => {
        const buf = new Uint8Array(e.data);
        const data = msgpack.decode(buf);
        log(`${msgCount++}: From Rust (RTC): ${JSON.stringify(data)}`);
      };
    };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    await new Promise(resolve => {
      if (pc.iceGatheringState === "complete") resolve();
      pc.onicegatheringstatechange = () => {
        if (pc.iceGatheringState === "complete") resolve();
      };
    });

    const offerB64 = btoa(JSON.stringify(pc.localDescription));

    const res = await fetch(ENDPOINT, {
      method: "POST",
      body: offerB64
    });

    const answer = JSON.parse(atob(await res.text()));
    await pc.setRemoteDescription(answer);

    log("WebRTC signaling complete");
  };

  // =======================================================
  // SSE
  // =======================================================
  document.getElementById("startSse").onclick = () => {
    if (sse) {
      log("SSE already connected");
      return;
    }

    log("Starting SSE…");

    sse = new EventSource(ENDPOINT);

    sse.onopen = () => {
      log("SSE connection open");
    };

    sse.onmessage = e => {
      // SSE delivers text → base64 → bytes
      const raw = atob(e.data);
      const bytes = new Uint8Array([...raw].map(c => c.charCodeAt(0)));
      const data = msgpack.decode(bytes);

      log(`${msgCount++}: From Rust (SSE): ${JSON.stringify(data)}`);
    };

    sse.onerror = () => {
      log("SSE connection closed");
      sse.close();
      sse = null;
    };
  };

  // =======================================================
  // Send message (RTC only)
  // =======================================================
  document.getElementById("send").onclick = () => {
    const input = document.getElementById("msg");
    const text = input.value.trim();

    if (!text || !rtcChannel || rtcChannel.readyState !== "open") return;

    rtcChannel.send(text);
    log("To Rust (RTC): " + text);
    input.value = "";
  };

  document.getElementById("msg").addEventListener("keydown", e => {
    if (e.key === "Enter") document.getElementById("send").click();
  });
})();
</script>

</body>
</html>
